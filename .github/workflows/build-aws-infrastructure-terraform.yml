name: Build AWS Infrastructure and Deploy Docker Flask App on it.

on:
  push:
    paths:
      - 'Terraform/**'
    branches: [ "main" ]

env:
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }} # AWS User Credentials.
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }} # AWS User Credentials.
  EC2_PRIVATE_SSH_KEY: ${{ secrets.AWS_EC2_SSH_PRIVATE_KEY }} # Used to ssh into EC2.
  EC2_PUBLIC_SSH_KEY: ${{ secrets.AWS_SSH_PUBLIC_KEY }} # Used to upload public key to aws.





jobs:
  build-aws:
    runs-on: ubuntu-latest
    
    outputs: # used to reference in later job
      EC2_PRIVATE_IP: ${{ steps.get-private-ip.outputs.ec2_private_ip}} 
      BASTION_PUBLIC_IP: ${{ steps.get-public-ip.outputs.bastion_public_ip}}
   
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v3

    
    - name: List files
      run: |-
        ls -R

    - name: setup terraform
      uses: hashicorp/setup-terraform@v1
      with:
        terraform_wrapper: false
 
    - name: Terraform Init
      id: init
      run: terraform init
      working-directory: ./Terraform
    
    # Checks that all Terraform configuration files adhere to a canonical format
    - name: Terraform Format
      run: terraform fmt -check
      working-directory: ./Terraform

    - name: Terraform Plan
      id: plan # we can do terraform plan -destroy to destroy all resources
      run: |-
        terraform plan -destroy \
        -var="public_key=$EC2_PUBLIC_SSH_KEY" \
        --var-file ./prod_values.tfvars \
        -out=PLAN       
      working-directory: ./Terraform


    - name: Terraform Apply
      id: apply
      run: terraform apply "PLAN"
      working-directory: ./Terraform

    - name: set-outputs-1
      id: get-private-ip
      run: echo "ec2_private_ip=$(terraform output application_private_ip_1)" >> $GITHUB_OUTPUT # new way of outputs
      working-directory: ./Terraform
   
    - name: set-outputs-2
      id: get-public-ip
      run: echo "bastion_public_ip=$(terraform output bastion_public_ip)" >> $GITHUB_OUTPUT # new way of outputs
      working-directory: ./Terraform


      
      # echo "::set-output name=bastion_public_ip::$(terraform output bastion_public_ip)"  old way of outputs
      # echo "::set-output name=application_private_ip_1::$(terraform output application_private_ip_1)" old way of outputs
      # echo "::set-output name={name}::{value}" old way of outputs
      # echo "{name}={value}" >> $GITHUB_OUTPUT # new way of outputs


  # New Job
  configure-aws:
    runs-on: ubuntu-latest
    needs: build-aws
    steps:
    - name: set private IP env variables
      run: echo EC2_PRIVATE_IP=${{ needs.build-aws.outputs.EC2_PRIVATE_IP }} >> $GITHUB_ENV

    - name: Use the value 1
      id: step_one
      run: |
        echo "${{ env.EC2_PRIVATE_IP }}" 

    - name: set public IP env variables
      run: echo BASTION_PUBLIC_IP=${{ needs.build-aws.outputs.BASTION_PUBLIC_IP }} >> $GITHUB_ENV
        
    - name: Use the value 2
      id: step_two
      run: |
        echo "${{ env.BASTION_PUBLIC_IP }}" 

      
    - name: Connect to Private EC2
      run: |- # # Add the host key of the remote server to the known_hosts file
        mkdir /home/runner/.ssh/
        touch /home/runner/.ssh/known_hosts
        ssh-keyscan -H $EC2_PRIVATE_IP >> ~/.ssh/known_hosts 
        echo "$EC2_PRIVATE_SSH_KEY" > private_key.pem && chmod 400 private_key.pem
        ssh -tt -o StrictHostKeyChecking=no -i private_key.pem -J ec2-user@$BASTION_PUBLIC_IP ec2-user@$EC2_PRIVATE_IP
        mkdir my_app
        cd ./my_app
        touch new_file.txt
        
      #  ssh -i $EC2_PRIVATE_SSH_KEY -J ec2-user@$BASTION_PUBLIC_IP ec2-user@$APPLICATION_PRIVATE_IP_1 --yes

      # env:
        # BASTION_PUBLIC_IP: ${{ steps.get-public-ip.outputs.bastion_public_ip}}
        # EC2_PRIVATE_IP: ${{ steps.get-private-ip.outputs.application_private_ip_1}}  

# ssh into ec2 public bastion then destroy it once done  using terraform destroy resource command and it needs the above commands to finish