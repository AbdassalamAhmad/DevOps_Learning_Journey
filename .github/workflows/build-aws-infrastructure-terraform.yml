name: Build AWS Infrastructure and Deploy Docker Flask App on it.

on:
  push:
    paths:
      - 'Terraform/**'
    branches: [ "main" ]

env:
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }} # AWS User Credentials.
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }} # AWS User Credentials.
  EC2_PRIVATE_SSH_KEY: ${{ secrets.AWS_EC2_SSH_PRIVATE_KEY }} # Used to ssh into EC2.
  EC2_PUBLIC_SSH_KEY: ${{ secrets.AWS_SSH_PUBLIC_KEY }} # Used to upload public key to aws.
  DESTROY: 'yes'




jobs:
  build-aws:
    runs-on: ubuntu-latest
    
    outputs: # used to reference in later job
      EC2_PRIVATE_IP: ${{ steps.get-private-ip.outputs.ec2_private_ip}} 
      BASTION_PUBLIC_IP: ${{ steps.get-public-ip.outputs.bastion_public_ip}}
   
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v3

    
    - name: List files
      run: |-
        ls -R

    - name: setup terraform
      uses: hashicorp/setup-terraform@v1
      with:
        terraform_wrapper: false
 
    - name: Terraform Init
      id: init
      run: terraform init
      working-directory: ./Terraform
    
    # Checks that all Terraform configuration files adhere to a canonical format
    - name: Terraform Format
      run: terraform fmt -check
      working-directory: ./Terraform

    - name: Terraform Plan Build
      if: env.DESTROY == 'no'
      id: build
      run: |-
        terraform plan \
        -var="public_key=$EC2_PUBLIC_SSH_KEY" \
        --var-file ./prod_values.tfvars \
        -out=PLAN       
      working-directory: ./Terraform
    
    - name: Terraform Plan Destroy
      if: env.DESTROY == 'yes'
      id: destroy 
      run: |-
        terraform plan -destroy \
        -var="public_key=$EC2_PUBLIC_SSH_KEY" \
        --var-file ./prod_values.tfvars \
        -out=PLAN       
      working-directory: ./Terraform

    - name: Terraform Apply
      id: apply
      run: terraform apply "PLAN"
      working-directory: ./Terraform

    - name: set-outputs-1
      id: get-private-ip
      run: echo "ec2_private_ip=$(terraform output application_private_ip_1)" >> $GITHUB_OUTPUT # new way of outputs
      working-directory: ./Terraform
   
    - name: set-outputs-2
      id: get-public-ip
      run: echo "bastion_public_ip=$(terraform output bastion_public_ip)" >> $GITHUB_OUTPUT # new way of outputs
      working-directory: ./Terraform


      # echo "{name}={value}" >> $GITHUB_OUTPUT # new way of outputs


  # New Job
  configure-aws:
    runs-on: ubuntu-latest
    needs: build-aws
    steps:
    - name: set private IP to env variables
      run: echo EC2_PRIVATE_IP=${{ needs.build-aws.outputs.EC2_PRIVATE_IP }} >> $GITHUB_ENV

    - name: set public IP to env variables
      run: echo BASTION_PUBLIC_IP=${{ needs.build-aws.outputs.BASTION_PUBLIC_IP }} >> $GITHUB_ENV
          
    - name: ssh into private EC2
      uses: appleboy/ssh-action@v0.1.6
      with:
        host: ${{ env.EC2_PRIVATE_IP }}
        username: ec2-user
        key: ${{ env.EC2_PRIVATE_SSH_KEY }}
        proxy_host: ${{ env.BASTION_PUBLIC_IP }}
        proxy_username: ec2-user
        proxy_key: ${{ env.EC2_PRIVATE_SSH_KEY }}
        script: |
          ls -al
          mkdir my_app
          cd ./my_app
          touch new_file.txt
          ls -al
# instead of running script, run Ansible playbook.          




# ssh into ec2 public bastion then destroy it once done 
# using terraform destroy resource command and it needs the above commands to finish.
# make it with if statement (if plan destroy dont do this job)