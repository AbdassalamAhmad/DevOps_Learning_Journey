name: Build AWS Infrastructure and Deploy Dockerized Flask-App on it.

on:
  push:
    paths:
      - 'Terraform/**'
    branches: [ "main" ]


env:
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }} # AWS User Credentials.
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }} # AWS User Credentials.
  EC2_PRIVATE_SSH_KEY: ${{ secrets.AWS_EC2_SSH_PRIVATE_KEY }} # Used to ssh into EC2.
  EC2_PUBLIC_SSH_KEY: ${{ secrets.AWS_SSH_PUBLIC_KEY }} # Used to upload public key to aws.
  DESTROY_ALL: 'no' # Make it 'no' to build AWS infra, and 'yes' to destroy it all.


jobs:
  build-aws-infra:
    runs-on: ubuntu-latest
    
    outputs: # used to reference in later job
      EC2_PRIVATE_IP: ${{ steps.get-private-ip.outputs.ec2_private_ip}} 
      BASTION_PUBLIC_IP: ${{ steps.get-public-ip.outputs.bastion_public_ip}}
   
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v3
 
    - name: setup terraform
      uses: hashicorp/setup-terraform@v1
      with:
        terraform_wrapper: false
 
    - name: Terraform Init
      id: init
      run: terraform init
      working-directory: ./Terraform
    
    # Checks that all Terraform configuration files in the correct format
    - name: Terraform Format
      run: terraform fmt -check
      working-directory: ./Terraform

    - name: Terraform Plan Build
      if: env.DESTROY_ALL == 'no' # will run when DESTROY_ALL is set to 'no'
      id: build
      run: |-
        terraform plan \
        -var="public_key=$EC2_PUBLIC_SSH_KEY" \
        --var-file ./prod_values.tfvars \
        -out=PLAN       
      working-directory: ./Terraform
    
    - name: Terraform Plan Destroy
      if: env.DESTROY_ALL == 'yes' # will run when DESTROY_ALL is set to 'yes'
      id: destroy 
      run: |-
        terraform plan -destroy \
        -var="public_key=$EC2_PUBLIC_SSH_KEY" \
        --var-file ./prod_values.tfvars \
        -out=PLAN       
      working-directory: ./Terraform

    - name: Terraform Apply
      id: apply
      run: terraform apply "PLAN"
      working-directory: ./Terraform

    - name: set-outputs-1
      id: get-private-ip
      run: echo "ec2_private_ip=$(terraform output application_private_ip_1)" >> $GITHUB_OUTPUT # new way of outputs
      working-directory: ./Terraform
   
    - name: set-outputs-2
      id: get-public-ip
      run: echo "bastion_public_ip=$(terraform output bastion_public_ip)" >> $GITHUB_OUTPUT # new way of outputs
      working-directory: ./Terraform
      # echo "{name}={value}" >> $GITHUB_OUTPUT # new way of outputs


  # New Job
  configure-aws-infra:
    runs-on: ubuntu-latest
    needs: build-aws-infra
    steps:
    - name: set private IP to env variables
      run: echo EC2_PRIVATE_IP=${{ needs.build-aws.outputs.EC2_PRIVATE_IP }} >> $GITHUB_ENV

    - name: set public IP to env variables
      run: echo BASTION_PUBLIC_IP=${{ needs.build-aws.outputs.BASTION_PUBLIC_IP }} >> $GITHUB_ENV
          
    - name: ssh into private EC2
      uses: appleboy/ssh-action@v0.1.6
      with:
        host: ${{ env.EC2_PRIVATE_IP }}
        username: ec2-user
        key: ${{ env.EC2_PRIVATE_SSH_KEY }}
        proxy_host: ${{ env.BASTION_PUBLIC_IP }}
        proxy_username: ec2-user
        proxy_key: ${{ env.EC2_PRIVATE_SSH_KEY }}
        script: |
          ls -al
          mkdir my_app
          cd ./my_app
          touch new_file.txt
          ls -al
# instead of running script, run Ansible playbook.          
    
    # Optional step to lower some cost after operation.
    - name: Terraform Plan Destroy Bstion Host
      if: env.DESTROY_ALL != 'yes' # when DESTROY_ALL = yes don't run this because it's already destroyed.
      id: destroy-bastion-host
      run: terraform destroy -target=aws_instance.bastion_instance_1
      working-directory: ./Terraform
